# --*-- coding: utf8 --*--

"""
算法问题
"""

"""
1. fabric
0 1 1 2 3 5 8 13

"""

def fabric(num):
    """
    获取num个fabric
    :param num:
    :return:
    """
    a, b = 1, 0
    print(b, end=' ')
    while num:
        a, b = a+b, a
        num -= 1
        print(a, end=' ')


# fabric(100)

"""
2.
（1）一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。
（2）一只青蛙一次可以跳上1级台阶，也可以跳上2 级……它也可以跳上n 级，此时该青蛙跳上一个n级的台阶总共有多少种跳法？

设 台阶共8阶, 有f(8)种跳法
第一次跳1阶, 剩下的台阶还有f(7)种跳法
第一次跳2阶, 剩下的台阶还有f(6)种跳法

那么, f(8) - f(7) = f(6)  即 f(8) = f(7) + f(6)
"""

def stage(num):
    """
    递归效率较低, 重复计算
    //时间复杂度O(n),空间复杂度O(n)
    :param num:
    :return:
    """
    if num == 0:
        return 0
    if num == 1:
        return 1
    if num == 2:
        return 2
    # f(2) = f(1)+f(0)
    return stage(num-1) + stage(num-2)

# print stage(10)


def stage2(num):
    """
    效率高
    //时间复杂度O(n),空间复杂度O(1)
    :param num:
    :return:
    """
    if num == 0:
        return 0
    if num == 1:
        return 1
    if num == 2:
        return 2
    a, b = 2, 1
    while num > 2:
        a, b = a+b, a
        num -= 1
    return a

# print stage2(10)

"""
官方:
2.一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。

问题分析:

设f(n)表示青蛙跳上n级台阶的跳法数。当只有一个台阶时，
即n = 1时， 只有1中跳法；
当n = 2时，有两种跳法；
当n = 3 时，有3种跳法；
当n很大时，青蛙在最后一步跳到第n级台阶时，有两种情况：
一种是青蛙在第n-1个台阶跳一个台阶，那么青蛙完成前面n-1个台阶，就有f(n-1)种跳法，这是一个子问题。
另一种是青蛙在第n-2个台阶跳两个台阶到第n个台阶，那么青蛙完成前面n-2个台阶，就有f(n-2)种情况，这又是另外一个子问题。

两个子问题构成了最终问题的解，所以当n>=3时，青蛙就有f(n)=f(n-1)+f(n-2)种跳法。上面的分析过程，
其实我们用到了动态规划的方法，找到了状态转移方程，用数学方程表达如下：

这里写图片描述
        1,               n=1
f(n) =  2,               n=2
        f(n-1)+f(n-2),   n>=3
仔细一看，这不就是传说中的著名的斐波那契数列，但是与斐波那契数列的还是有一点区别，
斐波那契数列从0开始，f(0)=0，f(1)=1,f(2)=1。斐波那契数列（Fibonacci Sequence），又称黄金分割数列，
因为当n趋于无穷大时，前一个数与后一个数的比值无限接近于黄金比例(√5?12的无理数，0.618…）



2.青蛙跳台阶问题可以引申为如下问题： 一只青蛙一次可以跳上1级台阶，也可以跳上2 级，……，也可以跳上n 级，
此时该青蛙跳上一个n级的台阶总共有多少种跳法？

当n = 1 时， 只有一种跳法，即1阶跳：Fib(1) = 1;
当n = 2 时， 有两种跳的方式，一阶跳和二阶跳：Fib(2) = Fib(1) + Fib(0) = 2;
当n = 3 时，有三种跳的方式，第一次跳出一阶后，后面还有Fib(3-1)中跳法；  2
                         第一次跳出二阶后，后面还有Fib(3-2)中跳法，  1
                         一次跳到第三台阶，后面还有Fib(3-3)中跳法，  1
                         Fib(3) = Fib(2) + Fib(1)+Fib(0)=4;
当n = n 时，共有n种跳的方式，第一次跳出一阶后，后面还有Fib(n-1)中跳法；
                          第一次跳出二阶后，后面还有Fib(n-2)中跳法….
                          第一次跳出n阶后, 后面还有Fib(n-n)中跳法。所以Fib(n) = Fib(n-1)+Fib(n-2)+Fib(n-3)+……….+Fib(1)，
又因为Fib(n-1)=Fib(n-2)+Fib(n-3)+…+Fib(1)，两式相减得：Fib(n)-Fib(n-1)=Fib(n-1)，所以Fib(n) = 2*Fib(n-1)，n >= 2。
递归等式如下,
        1,               n=1
f(n) =
        2f(n-1),         n>1
"""

def stage_n(n):
    if n == 1:
        return 1
    return 2*stage_n(n-1)

# print stage_n(5)


"""
3. 格子填充问题
-------------------
|   |    |    |    |
-------------------
|   |    |    |    |
--------------------

用两个格子去填充8个格子的方法有几种(格子不覆盖)
2个格子  f(2) = 1
4个格子  f(4) = 2
6个格子  f(6) = f(2) + f(4)
8个格子  f(8) = f(4)  + f(6)
n个格子  f(n) = f(n-4) + f(n-2)
"""

def stage_n2(n):
    if n % 2:
        print("input error")
        return
    if n == 2:
        return 1
    if n == 4:
        return 2
    return stage_n2(n-2)+stage_n2(n-4)

print(stage_n2(10))


